20190120
图片验证码获取，提交校验部分已经完成，主要关键点在，cookie和token都要在接口获取才有效。
目前发现注册过的手机号可以再次接收验证码。
卡在最后注册的步骤，总是返回130010：请您输入密码 怀疑是rsa算法的问题。
查看了公钥的返回数据，转换成十六进制之后发现包含了010001，想办法去掉之后，问题依旧。
经过断包测试后基本确定是rsa的算法或者是key的问题了。
研究js发现公钥base64解码后转成16进制，跟正常的有区别。明天再研究了。
20190121
通过在chrome下断点发现，公钥base64解码之后，再转成十六进制字符，然后还会再经过百度自己的算法再转一次十六进制。
目前方案是直接复制js算法。然后调用他的算法再转一次十六进制。
js算法实现，大概步骤是，先把getpublickey 接口取到的公钥先base64解码得到byte,再转化为十六进制字符，然后再自己写个js的funcion
把十六进制再次转化成array.其实也是byte，（这一步其实可以不做，可以直接把base64转出来的放到js，但是写了的代码不好改就直接用了。）
然后再经过百度自己的js算法转成十六进制的公钥，再放到rsautils里加密就可以了。
20190123
基本功能实现后发现有时候验证码的图加载不出来，看来要优化一下clear函数。
暂时思路是直接取图片固定格式的头部 来做前段截取，因为验证码图片格式只有两三种。
20190124
优化了clear算法，直接用png头部数据 来做开始位置，不再搜索换行符。
java 的十六进制转byte 转成10进制后，如果超过127.要减去256 得到的负数才是 java里对应的byte.比如十六进制 89 对应十进制是137，超过了127就要137-256=-119.-119就是java里的137的表达。

20190222
准备实现登录功能，抓包发现密码加密方式跟注册的套路是一样的，重温一下算法，准备明天再实现。。。。

